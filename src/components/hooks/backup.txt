import { useState, useEffect, useRef, useCallback } from "react";
import { fetchAutocomplete } from "../../services/googlePlacesService"; // ✅ API 호출 파일 불러오기
import debounce from "lodash.debounce"; // ✅ Debounce를 사용하여 API 요청 최적화
// ✅ RESTful API 요청을 travelSearchLogic.js에서 가져오도록 변경
import {
  getRecentSearches, // 최근 검색어 목록 조회
  saveSearch, // 검색어 저장
  deleteRecentSearch, // 검색어 삭제
  getPopularDestinations, // 인기 여행지 목록 조회
} from "../../services/travelSearchLogic";

// 🔽 커스텀 훅 생성: 여행 검색 관련 상태와 기능을 관리
const useTravelSearch = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false); // 🔹 로그인 상태 확인
  const [searchTerm, setSearchTerm] = useState(""); // 🔹 검색어 상태
  const [showResults, setShowResults] = useState(false); // 🔹 검색 결과 표시 여부
  const [selectedCity, setSelectedCity] = useState(""); // 🔹 선택된 도시
  const [recentSearches, setRecentSearches] = useState([]); // 🔹 최근 검색어 목록
  const [popularDestinations, setPopularDestinations] = useState([]); // 🔹 인기 여행지 목록
  const [suggestedCombined, setSuggestedCombined] = useState([]); // 🔹 자동완성 추천 결과
  const searchResultsRef = useRef(null); // 🔹 검색 결과 DOM 영역 참조
  const [isSearching, setIsSearching] = useState(false); // 자동완성 결과 갱신 함수

  // ✅ [추가] 검색어 입력 시 자동완성 API 호출
  useEffect(() => {
    const fetchSuggestions = async () => {
      if (!searchTerm.trim()) {
        setSuggestedCombined([]);
        setShowResults(false);
        return;
      }

      try {
        setIsSearching(true); // 로딩 시작
        const results = await fetchAutocomplete(searchTerm);
        updateSuggestedCombined(results);
        setShowResults(true); // 자동완성 결과 표시
      } catch (error) {
        console.error("❌ 자동완성 API 호출 오류:", error);
      } finally {
        setIsSearching(false); // 로딩 종료
      }
    };

    fetchSuggestions();
  }, [searchTerm]);

  // ✅ 로그인 상태 확인 및 최근 검색어 불러오기
  useEffect(() => {
    const checkLoginStatus = async () => {
      const accessToken = localStorage.getItem("accessToken");
      const userId = localStorage.getItem("user_id");

      if (accessToken && userId) {
        setIsLoggedIn(true);
        try {
          const searches = await getRecentSearches(userId, accessToken);
          setRecentSearches(Array.isArray(searches) ? searches : []);
        } catch (error) {
          console.error("❌ 최근 검색어 불러오기 실패:", error);
        }
      } else {
        setIsLoggedIn(false);
        setRecentSearches([]); // 로그아웃 시 초기화
      }
    };

    checkLoginStatus();
    window.addEventListener("storage", checkLoginStatus);
    return () => window.removeEventListener("storage", checkLoginStatus);
  }, []);

  // ✅ 인기 여행지 불러오기
  useEffect(() => {
    const loadPopular = async () => {
      try {
        const data = await getPopularDestinations();
        console.log("🔥 인기 여행지 응답:", data);
        setPopularDestinations(data);
      } catch (error) {
        console.error("❌ 인기 여행지 불러오기 실패:", error);
      }
    };
    loadPopular();
  }, []);

  // ✅ 검색어 저장
  const handleSaveSearch = async (term, type = "city") => {
    if (!isLoggedIn) return;
    try {
      const accessToken = localStorage.getItem("accessToken");
      await saveSearch(term, type, accessToken);
      const userId = localStorage.getItem("user_id");
      const updated = await getRecentSearches(userId, accessToken);
      setRecentSearches(updated);
    } catch (error) {
      console.error("❌ 검색어 저장 실패:", error);
    }
  };

  // ✅ 검색어 삭제
  const handleRemoveRecentSearch = async (term, type = "city") => {
    if (!isLoggedIn) return;
    try {
      const accessToken = localStorage.getItem("accessToken");
      await deleteRecentSearch(term, accessToken); // type 제거
      const userId = localStorage.getItem("user_id");
      const updated = await getRecentSearches(userId, accessToken);
      setRecentSearches(updated);
    } catch (error) {
      console.error("❌ 검색어 삭제 실패:", error);
    }
  };

  // ✅ 자동완성 결과 갱신
  const updateSuggestedCombined = (results) => {
    setSuggestedCombined(results || []);
  };

  // ✅ 도시 선택 처리
  const handleCitySelect = (city) => {
    setSelectedCity(city);
    setSearchTerm(city);
    setShowResults(false);
  };

  // ✅ 인기 여행지 선택 처리
  const handlePopularDestinationSelect = async (destination) => {
    setSearchTerm(destination);
    setSelectedCity(destination);
    setShowResults(false);

    if (!isLoggedIn) {
      console.log("❌ 로그인되지 않음 - 검색어 저장 안 함");
      return; // 📌 로그인하지 않으면 저장하지 않음
    }

    try {
      const accessToken = localStorage.getItem("accessToken");
      // ✅ RESTful API 호출로 변경
      const updatedSearches = await saveSearch(
        destination,
        "city",
        accessToken
      );
      setRecentSearches(updatedSearches);

      console.log("✅ 인기 여행지 선택 및 검색어 저장 완료:", destination);
    } catch (error) {
      console.error("❌ 검색어 저장 실패:", error);
    }
  };

  // ✅ 검색창 외부 클릭 시 검색 결과 닫기
  const handleClickOutside = (event) => {
    if (
      searchResultsRef.current &&
      !searchResultsRef.current.contains(event.target)
    ) {
      setShowResults(false);
    }
  };

  // ✅ 검색어 초기화
  const handleClearSearch = () => {
    setSearchTerm("");
    setSelectedCity("");
    setShowResults(false);
    setSuggestedCombined([]);
  };

  return {
    isLoggedIn, // 🔹 로그인 여부 추가
    currentUser, // 🔹 현재 로그인한 사용자 정보 추가
    searchTerm, // 🔹 검색어 상태
    showResults, // 🔹 검색 결과 표시 여부
    selectedCity, // 🔹 선택된 도시
    setSelectedCity, // ✅ 이 줄 추가!!
    recentSearches, // 🔹 최근 검색어 목록
    suggestedCities, // 🔹 추천 도시 목록
    popularDestinations, // 🔹 인기 여행지 목록
    searchResultsRef, // 🔹 검색 결과 DOM 참조
    handleCountryChange, // 🔹 나라 입력 시 자동완성 처리
    fetchPlaces, // 🔹 공통 검색 함수
    saveSearch, // 🔹 검색어 저장 함수 (백엔드 API 호출)
    setSearchTerm, // 🔹 검색어 변경 함수
    setShowResults, // 🔹 검색 결과 표시 여부 설정
    handleClearSearch, // 🔹 검색어 초기화
    handleCitySelect, // 🔹 도시 선택 처리
    handleCountrySelect, // 🔹 나라 선택 처리
    handlePopularDestinationSelect, // 🔹 인기 여행지 선택 처리
    handleClickOutside, // 🔹 검색창 외부 클릭 시 닫기
    getSuggestedCities, // 🔹 도시 추천 기능 (더미 데이터 + API 사용)
    handleRemoveRecentSearch, // 🔹 최근 검색어 삭제
    updateRecentSearches, // 🔹 최근 검색어 업데이트
  };
};

export default useTravelSearch;
